// Thread service that interfaces with Tauri commands (SeaORM backend)
import { invoke } from '@tauri-apps/api/core';
import {
  Thread,
  ThreadMessage,
  CreateThreadRequest,
  UpdateThreadRequest,
  CreateThreadMessageRequest,
  ThreadAssignment,
} from '../../../types';
import { getDatabaseErrorMessage } from '../utils';
import { TranslationKey } from '../../../i18n';
import {
  generateThreadTitle,
  isAutoGeneratedTitle,
} from '../../../utils/threadTitleUtils';

export class ThreadService {
  /**
   * Create a new thread
   */
  async create(request: CreateThreadRequest): Promise<Thread> {
    try {
      // Map frontend camelCase to backend snake_case and serialize data
      const serializedRequest = {
        assignment_type: request.assignment?.type,
        assignment_task_id: request.assignment?.taskId,
        assignment_date: request.assignment?.date?.toISOString(),
        assignment_context: request.assignment?.context,
      };

      const result = await invoke<Record<string, unknown>>('create_thread', {
        request: serializedRequest,
      });
      return this.transformThreadFromBackend(result);
    } catch (error) {
      console.error('Thread creation failed with error:', error);
      throw new Error(`Failed to create thread: ${error}`);
    }
  }

  /**
   * Find thread by ID
   */
  async findById(id: string): Promise<Thread | null> {
    try {
      const result = await invoke<Record<string, unknown> | null>(
        'get_thread',
        {
          id,
        }
      );
      return result ? this.transformThreadFromBackend(result) : null;
    } catch (error) {
      throw this.handleDatabaseError(error, 'find thread');
    }
  }

  /**
   * Find all threads
   */
  async findAll(): Promise<Thread[]> {
    try {
      const result = await invoke<Record<string, unknown>[]>('get_all_threads');
      return result.map(thread => this.transformThreadFromBackend(thread));
    } catch (error) {
      throw this.handleDatabaseError(error, 'load threads');
    }
  }

  /**
   * Find threads by task ID
   */
  async findByTaskId(taskId: string): Promise<Thread[]> {
    try {
      const result = await invoke<Record<string, unknown>[]>(
        'get_threads_by_task',
        {
          taskId: taskId,
        }
      );
      return result.map(thread => this.transformThreadFromBackend(thread));
    } catch (error) {
      const errorMessage = getDatabaseErrorMessage(
        'threadService.error.findByTaskFailed' as TranslationKey
      );
      throw new Error(`${errorMessage}: ${error}`);
    }
  }

  /**
   * Find threads by date
   */
  async findByDate(date: Date): Promise<Thread[]> {
    try {
      const result = await invoke<Record<string, unknown>[]>(
        'get_threads_by_date',
        {
          date: date.toISOString().split('T')[0], // Send as YYYY-MM-DD
        }
      );
      return result.map(thread => this.transformThreadFromBackend(thread));
    } catch (error) {
      const errorMessage = getDatabaseErrorMessage(
        'threadService.error.findByDateFailed' as TranslationKey
      );
      throw new Error(`${errorMessage}: ${error}`);
    }
  }

  /**
   * Update thread
   */
  async update(id: string, request: UpdateThreadRequest): Promise<Thread> {
    try {
      // Map frontend camelCase to backend snake_case and serialize data
      const serializedRequest: Record<string, unknown> = {};

      if (request.title !== undefined) {
        serializedRequest.title = request.title;
      }
      if (request.assignment !== undefined) {
        serializedRequest.assignment_type = request.assignment?.type;
        serializedRequest.assignment_task_id = request.assignment?.taskId;
        serializedRequest.assignment_date =
          request.assignment?.date?.toISOString();
        serializedRequest.assignment_context = request.assignment?.context;
      }

      const result = await invoke<Record<string, unknown>>('update_thread', {
        id,
        request: serializedRequest,
      });
      return this.transformThreadFromBackend(result);
    } catch (error) {
      throw this.handleDatabaseError(error, 'update thread');
    }
  }

  /**
   * Delete thread
   */
  async delete(id: string): Promise<void> {
    try {
      await invoke<string>('delete_thread', { id });
    } catch (error) {
      throw this.handleDatabaseError(error, 'delete thread');
    }
  }

  /**
   * Create a thread message
   */
  async createMessage(
    request: CreateThreadMessageRequest
  ): Promise<ThreadMessage> {
    try {
      // Map frontend camelCase to backend snake_case and serialize data
      const serializedRequest = {
        thread_id: request.threadId,
        type: request.type,
        content: request.content,
        reasoning: request.reasoning,
        actions: request.actions,
        suggestions: request.suggestions,
        tool_executions: request.toolExecutions,
        timestamp: new Date().toISOString(),
      };

      const result = await invoke<Record<string, unknown>>(
        'create_thread_message',
        {
          request: serializedRequest,
        }
      );

      const message = this.transformThreadMessageFromBackend(result);

      // Auto-generate thread title from first user message
      if (request.type === 'user') {
        await this.updateThreadTitleIfNeeded(request.threadId, request.content);
      }

      return message;
    } catch (error) {
      console.error('Thread message creation failed with error:', error);
      throw this.handleDatabaseError(error, 'create thread message');
    }
  }

  /**
   * Find messages for a thread
   */
  async findMessages(threadId: string): Promise<ThreadMessage[]> {
    try {
      const result = await invoke<Record<string, unknown>[]>(
        'get_thread_messages',
        {
          threadId: threadId,
        }
      );
      return result.map(message =>
        this.transformThreadMessageFromBackend(message)
      );
    } catch (error) {
      throw this.handleDatabaseError(error, 'load thread messages');
    }
  }

  /**
   * Find a specific message by ID
   */
  async findMessageById(id: string): Promise<ThreadMessage | null> {
    try {
      const result = await invoke<Record<string, unknown> | null>(
        'get_thread_message',
        {
          id,
        }
      );
      return result ? this.transformThreadMessageFromBackend(result) : null;
    } catch (error) {
      const errorMessage = getDatabaseErrorMessage(
        'threadService.error.findMessageFailed' as TranslationKey
      );
      throw new Error(`${errorMessage}: ${error}`);
    }
  }

  /**
   * Update a thread message (mainly for user feedback)
   */
  async updateMessage(
    id: string,
    userFeedback?: unknown
  ): Promise<ThreadMessage> {
    try {
      const result = await invoke<Record<string, unknown>>(
        'update_thread_message',
        {
          id,
          user_feedback: userFeedback,
        }
      );
      return this.transformThreadMessageFromBackend(result);
    } catch (error) {
      const errorMessage = getDatabaseErrorMessage(
        'threadService.error.updateMessageFailed' as TranslationKey
      );
      throw new Error(`${errorMessage}: ${error}`);
    }
  }

  /**
   * Delete a thread message
   */
  async deleteMessage(id: string): Promise<void> {
    try {
      await invoke<string>('delete_thread_message', { id });
    } catch (error) {
      const errorMessage = getDatabaseErrorMessage(
        'threadService.error.deleteMessageFailed' as TranslationKey
      );
      throw new Error(`${errorMessage}: ${error}`);
    }
  }

  /**
   * Get thread statistics
   */
  async getStatistics(): Promise<{
    totalThreads: number;
    totalMessages: number;
    taskThreads: number;
    dayThreads: number;
    generalThreads: number;
  }> {
    try {
      const result = await invoke<{
        total_threads: number;
        total_messages: number;
        task_threads: number;
        day_threads: number;
        general_threads: number;
      }>('get_thread_statistics');

      return {
        totalThreads: result.total_threads,
        totalMessages: result.total_messages,
        taskThreads: result.task_threads,
        dayThreads: result.day_threads,
        generalThreads: result.general_threads,
      };
    } catch (error) {
      throw new Error(`Failed to get thread statistics: ${error}`);
    }
  }

  /**
   * Transform thread data from backend format to frontend format
   */
  private transformThreadFromBackend(
    backendThread: Record<string, unknown>
  ): Thread {
    const assignment: ThreadAssignment | undefined =
      backendThread.assignment_type
        ? {
            type: backendThread.assignment_type as 'task' | 'day' | 'general',
            taskId: backendThread.assignment_task_id as string | undefined,
            date: backendThread.assignment_date
              ? new Date(backendThread.assignment_date as string)
              : undefined,
            context: this.parseJsonField(
              backendThread.assignment_context as string | null,
              {}
            ),
          }
        : undefined;

    return {
      id: backendThread.id as string,
      title: backendThread.title as string,
      assignment,
      messageCount: (backendThread.message_count as number) || 0,
      lastMessageAt: backendThread.last_message_at
        ? new Date(backendThread.last_message_at as string)
        : undefined,
      createdAt: new Date(backendThread.created_at as string),
      updatedAt: new Date(backendThread.updated_at as string),
    };
  }

  /**
   * Transform thread message data from backend format to frontend format
   */
  private transformThreadMessageFromBackend(
    backendMessage: Record<string, unknown>
  ): ThreadMessage {
    return {
      id: backendMessage.id as string,
      threadId: backendMessage.thread_id as string,
      type: backendMessage.type as 'user' | 'assistant',
      content: backendMessage.content as string,
      reasoning: backendMessage.reasoning as string | undefined,
      actions: this.parseJsonField(backendMessage.actions as string | null, []),
      suggestions: this.parseJsonField(
        backendMessage.suggestions as string | null,
        []
      ),
      toolExecutions: this.parseJsonField(
        backendMessage.tool_executions as string | null,
        []
      ),
      timestamp: new Date(backendMessage.timestamp as string),
      userFeedback: this.parseJsonField(
        backendMessage.user_feedback as string | null,
        undefined
      ),
    };
  }

  /**
   * Update thread title if needed (for auto-generation from first message)
   */
  private async updateThreadTitleIfNeeded(
    threadId: string,
    messageContent: string
  ): Promise<void> {
    try {
      // Get the current thread
      const thread = await this.findById(threadId);
      if (!thread) {
        return;
      }

      // Check if this is the first user message by checking message count
      const messages = await this.findMessages(threadId);
      const userMessages = messages.filter(m => m.type === 'user');

      // Only update title if this is the first user message and the current title is auto-generated
      if (
        userMessages.length <= 1 &&
        (isAutoGeneratedTitle(thread.title) || thread.title === 'New Thread')
      ) {
        const newTitle = generateThreadTitle(messageContent);

        // Update the thread title
        await this.update(threadId, { title: newTitle });
      }
    } catch (error) {
      // Don't throw error for title update failures, just log them
      console.warn('Failed to update thread title:', error);
    }
  }

  /**
   * Parse JSON field with fallback
   */
  private parseJsonField<T>(value: string | null, fallback: T): T {
    if (!value) {
      return fallback;
    }
    try {
      return JSON.parse(value) as T;
    } catch {
      return fallback;
    }
  }

  /**
   * Handle database errors with enhanced error messages and categorization
   */
  private handleDatabaseError(error: unknown, operation: string): Error {
    let errorMessage = `Failed to ${operation}`;
    let isConnectionError = false;
    let isConstraintError = false;
    let isTimeoutError = false;

    if (typeof error === 'string') {
      errorMessage = error;
    } else if (error instanceof Error) {
      errorMessage = error.message;
    }

    // Remove redundant prefixes
    errorMessage = errorMessage.replace(/^Failed to [^:]+:\s*/, '');
    errorMessage = errorMessage.replace(/^Database error:\s*/, '');

    // Categorize error types for better handling
    const lowerMessage = errorMessage.toLowerCase();

    if (
      lowerMessage.includes('connection') ||
      lowerMessage.includes('network') ||
      lowerMessage.includes('unreachable') ||
      lowerMessage.includes('refused')
    ) {
      isConnectionError = true;
      errorMessage =
        'Database connection failed. Please check your network connection and try again.';
    } else if (
      lowerMessage.includes('timeout') ||
      lowerMessage.includes('timed out')
    ) {
      isTimeoutError = true;
      errorMessage = 'Database operation timed out. Please try again.';
    } else if (
      lowerMessage.includes('constraint') ||
      lowerMessage.includes('unique') ||
      lowerMessage.includes('foreign key')
    ) {
      isConstraintError = true;
      errorMessage =
        'Data validation failed. Please check your input and try again.';
    } else if (
      lowerMessage.includes('not found') ||
      lowerMessage.includes('no such')
    ) {
      errorMessage =
        'Requested data was not found. It may have been deleted or moved.';
    } else if (
      lowerMessage.includes('permission') ||
      lowerMessage.includes('access denied')
    ) {
      errorMessage =
        'Access denied. You may not have permission to perform this operation.';
    } else if (
      lowerMessage.includes('disk') ||
      lowerMessage.includes('space')
    ) {
      errorMessage =
        'Insufficient storage space. Please free up disk space and try again.';
    } else if (
      lowerMessage.includes('locked') ||
      lowerMessage.includes('busy')
    ) {
      errorMessage =
        'Database is currently busy. Please try again in a moment.';
    }

    // Create enhanced error with metadata
    const enhancedError = new Error(errorMessage) as Error & {
      isConnectionError: boolean;
      isConstraintError: boolean;
      isTimeoutError: boolean;
      originalError: unknown;
      operation: string;
    };
    enhancedError.isConnectionError = isConnectionError;
    enhancedError.isConstraintError = isConstraintError;
    enhancedError.isTimeoutError = isTimeoutError;
    enhancedError.originalError = error;
    enhancedError.operation = operation;

    return enhancedError;
  }
}
